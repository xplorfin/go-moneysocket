package beacon

import (
	"bytes"
	"encoding/hex"
	"testing"

	"github.com/xplorfin/moneysocket-go/moneysocket/util"

	"github.com/brianvoe/gofakeit/v6"
)

// the test cases below were manually verified against the python version
// if we plan on support socket.money long term these integration tests should
// be done through a harness

// SharedSeedTestCase defines a test case to test the beacon package against
type SharedSeedTestCase struct {
	// Seed used to generate the beacon
	Seed []byte
	// InputBytes for testing internal functions
	InputBytes []byte
	// Sha256 generated from input bytes
	Sha256 string
	// generated double sha-256 from input bytes
	DoubleSha256 string
	// generated aes-256
	Aes256Key string
	// generated rendezvous id
	RendezvousId string
	// generated encoded-tlv
	EncodedTlv string
}

var testCases = []SharedSeedTestCase{
	{
		Seed:         []byte("hello from light"),
		InputBytes:   []byte("test"),
		Sha256:       "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
		DoubleSha256: "954d5a49fd70d9b8bcdb35d252267829957f7ef7fa6c74f88419bdc5e82209f4",
		Aes256Key:    "48dacfc16eed1b0a40891c73655ae8137960de419841432c4bbeea2bcaeacd83",
		RendezvousId: "d678c107fe2913ae1ab79bfba00694aaed75b5a2b0187ea0719919cbfedf9758",
		EncodedTlv:   "fe000101bd1068656c6c6f2066726f6d206c69676874",
	},
}

// TestSharedSeedParity will test encoding with SharedSeed against python test cases
func TestSharedSeedParity(t *testing.T) {
	for _, test := range testCases {
		ss, err := BytesToSharedSeed(test.Seed)
		if err != nil {
			t.Error(err)
		}
		if test.Sha256 != ss.SHA256(test.InputBytes) {
			t.Errorf("expected sha-256 key %s to match %s for seed %s", test.Sha256, ss.SHA256(test.InputBytes), test.Seed)
		}
		if test.DoubleSha256 != hex.EncodeToString(ss.DoubleSHA256(test.InputBytes)) {
			t.Errorf("expected double-sha256 key %s to match %s for seed %s", test.Sha256, hex.EncodeToString(ss.DoubleSHA256(test.InputBytes)), test.Seed)
		}
		if test.Aes256Key != hex.EncodeToString(ss.DeriveAES256Key()) {
			t.Errorf("expected aes-256 key %s to match %s for seed %s", test.Aes256Key, hex.EncodeToString(ss.DeriveAES256Key()), test.Seed)
		}
		if test.RendezvousId != hex.EncodeToString(ss.DeriveRendezvousId()) {
			t.Errorf("expected rendezvous id %s to match %s for seed %s", test.RendezvousId, hex.EncodeToString(ss.DeriveRendezvousId()), test.Seed)
		}
		if test.EncodedTlv != hex.EncodeToString(ss.EncodedTLV()) {
			t.Errorf("expected encodedtlv %s to match %s", test.EncodedTlv, hex.EncodeToString(ss.EncodedTLV()))
		}
	}
}

// tests that shared seeds generated by hex and byte slice are equal
// also tests determinism on all methods
func TestHexEquality(t *testing.T) {
	for i := 0; i < 100; i++ {
		seedBytes, err := util.GenerateRandomBytes(16)
		if err != nil {
			t.Error(err)
		}
		byteSeed, err := BytesToSharedSeed(seedBytes)
		if err != nil {
			t.Error(err)
		}
		hexSeed, err := HexToSharedSeed(hex.EncodeToString(seedBytes))
		if err != nil {
			t.Error(err)
		}
		if !hexSeed.Equal(byteSeed) {
			t.Error("expected byte and hex seed to be equal")
		}
		if !byteSeed.Equal(hexSeed) {
			t.Error("expected byte and hex seed to be equal")
		}

		if !bytes.Equal(byteSeed.GetBytes(), hexSeed.GetBytes()) {
			t.Error("expected byte and hex seed to be equal for GetBytes()")
		}

		if byteSeed.SHA256(seedBytes) != hexSeed.SHA256(seedBytes) {
			t.Error("expected byte and hex seed to be equal for SHA256()")
		}

		if byteSeed.Hex() != hexSeed.Hex() {
			t.Error("expected byte and hex seed to be equal for Hex()")
		}

		if byteSeed.Hash() != hexSeed.Hash() {
			t.Error("expected byte and hex seed to be equal for Hash()")
		}

		if byteSeed.ToString() != hexSeed.ToString() {
			t.Error("expected byte and hex seed to be equal for ToString()")
		}

		if !bytes.Equal(byteSeed.DoubleSHA256(seedBytes), hexSeed.DoubleSHA256(seedBytes)) {
			t.Error("expected byte and hex seed to be equal for DoubleSHA256()")
		}

		if !bytes.Equal(byteSeed.DeriveAES256Key(), hexSeed.DeriveAES256Key()) {
			t.Error("expected byte and hex seed to be equal for DeriveAES256Key()")
		}

		if !bytes.Equal(byteSeed.DeriveRendezvousId(), hexSeed.DeriveRendezvousId()) {
			t.Error("expected byte and hex seed to be equal for DeriveAES256Key()")
		}

		if !bytes.Equal(byteSeed.EncodedTLV(), hexSeed.EncodedTLV()) {
			t.Error("expected byte and hex record to be equal for encoded()")
		}

	}
}

func TestInvalidSeed(t *testing.T) {
	gofakeit.Seed(0)
	for i := 0; i < 1000; i++ {
		seed := gofakeit.Sentence(gofakeit.RandomInt([]int{15, 20}))
		if len([]byte(seed)) == 16 {
			continue // seed is correct length
		}
		ss, err := BytesToSharedSeed([]byte(seed))
		if err == nil {
			t.Errorf("invalid seed %s of length %d appears to be valid, should be invalid", ss.GetBytes(), len(ss.GetBytes()))
		}

	}
}
